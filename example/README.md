## CLINTEST

Дизайн самого инструмента предлагается сделать подобным [gtest](https://github.com/google/googletest).

Рассмотрим пример:

В файле [test](./test.cpp) можно найти некоторый тестируемый C++
код. Код на пути к тестированию проходит следующий пайплайн.

### Встроенная кодогенерация.
В данный момент это макрос `LTEST` из примера. Предполагается, что код теста - это код одного потока тестируемой программы. Здесь хочется поддержать следующие фичи:
   - Входные данные для теста:
   ```cpp
   LTEST(test_add, Adder ad) {
    ad.add();
    int x = add.get();
   }
   ```
   Входные аргументы будут сконструированы перед запуском каждого теста. Можно в первое время огранчичиться одним входны классом.
   Пользователь сможет хранить в нем всю необходимую информацию, которая будет шариться между потоками.

   - Переменную, которая сообщает тесту, в каком абстрактном потоке
   он запущен, что-то вроде (похоже на наш собственный интринсик):
   ```cpp
   LTEST(test_add2, int thread_num) {
    if (thread_num == 0) {
        work1();
    } else {
        work2();
    }
   }
   ```
### Генерация корутин в LLVM IR представлении.

Здесь можно посмотреть на пример в файле [test.ll](./test.ll). Вся
подразумевающаяся кодогенерация в нем отмечена `[!]`.
Нужно:
* Отыскать функции, которые мы будем превращать в корутины. На
первых порах можно считать, что это все функции в файле.
* Сгенерировать для них корутиный код. Для этого:
   - сгенерировать блок с инициализацией handle
   - разбить сам код функции на базовые блоки и в конце этих блоков
   сгенерировать точки прерываний.
   - в местах вызова функций бывших обычных функций нужно
   сгенерировать специальный код для вызова корутины и уведомления
   планировщика об этом вызове.
   - сгенерировать метод `main`, в котором по очереди вызвать тесты
   для всех функций вида `test_*` из входного файла.

### Executor

TODO

[executor.cpp](./executor.cpp).

### Scheduler

TODO

[scheduler.cpp](./scheduler.h)

