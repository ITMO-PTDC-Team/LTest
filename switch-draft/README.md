Цели:
1. Нужно уметь проверять примитив, для этого нужно уметь проверять каждое исполнение
2. Исполнение - последовательная история, чтобы ее проверить - нужно сначала ее получить в каком-то виде
3. Нужно уметь генерировать исполнение, те уметь исполнять куски методов в произвольном порядке

Начнем с 3.

Для генерации исполнения нужно как-то исполнять операции и уметь переключаться между ними
Самый простой вариант - исполнять все в одном потоке и переключаться в особых точках
Те нужны switch point'ы
Вопрос: Хотим ли мы чтобы switch-point иногда срабатывал, а иногда нет(между разными вызовами одной операции)?
Ответ: Было-бы круто
Реализация такой штуки схема user -> scheduler -> user, в каждом свитче передаем управление в цикл планирования, тот сделает switch на кого надо
В switch-point нужно смотреть на какую-то ячейку памяти, и в зависимости от нее делать switch или нет. Просто иногда сразу возвращаем, а иногда нет. Нужен asm который будет переставлять регистр на scheduler.
В какой момент воткнуть switch? После операций из условного конфига(вызовов std)
Как воткнуть? llvm pass
Poc:
Шаг 1 - попробовать напихать после каждого библиотечного вызова - std::out << “hello”; (Сделано)
Шаг 2 - передать там управление в другое место

Проблема: У нас корутины, но схема в любом случае должна оставаться user_code -> switch -> scheduler -> user_code.
Кажется, что именно с корутинами проще делать co_await и все, но мне хочется, чтобы мы могли так тестить не только корутины. Поэтому я бы хочу подумать можно ли тестить корутины обычными свитчами

PS:
Использование этого кода:
```cmake .```
```ninja```
```clang++ -O0 -fpass-plugin=switch_insert/SwitchPass.so example.cpp switch.cpp -o magic```
Результат
``` » ./magic                                                                                                                        130 ↵ svilex@svilexLin
hello from switch
hello from main
hello from switch
hello from main 2
```
Из проблем - нужен `extern "C"`, тк mangling на стороне front-end(clang++), много страдал с builder
